The following chapter contains a description of the most relevant technologies used in the project. For each technology, we describe the characteristics most relevant for this project.

\section{Glasgow Haskell Compiler}
From the currently available Haskell compilers, we use the Glasgow Haskell Compiler (GHC) for interpreting the Haskell exercises and running tests for the submissions. GHC is recommended by the Haskell Organisation and it is recommended as the go-to compiler/interpreter by the \textit{Programming Paradigms} lecturer\cite{Haskell_GHC}.


\section{Hspec}
To run Haskell tests, we needed a test framework. A test framework is a framework that allows a developer to set up specifications that code must satisfy to pass a test.
A test asserts whether code behaves as expected given some input based on system requirements.
We can use this to automatically run the tests on student exercise submissions.
This allows us to confirm if the students solved the exercise and if not, inform them which tests did not pass.
Among the available options, Hspec was chosen as it allows the lecturer to define tests in an easy-to-understand domain-specific language (DSL).
This makes the framework easier to work with, which, in turn, also makes it easier for the lecturer to define exercises using our system.\cite{Hspec_landing}

An example setup of an Hspec test can be seen in code snippet \ref{lst:HspecTestExample}. First, Hspec and the module defined in the student's code are imported. Then the specification describing the test Hspec should run in the code is defined. In code snippet \ref{lst:HspecTestExample}, the function \textit{Function Name} is called on the input variable \texttt{x} and the expected output is \texttt{y}, which can be a value of any type.


\begin{lstlisting}[language=CSharp, caption={An example of a Hspec test}, label={lst:HspecTestExample}]
{
 module moduleNameSpec (spec, main) where

 import Test.Hspec
 import moduleName (functionName)

 spec = Spec
 spec = do
 	describe "Function Name" do
 	it "Test description" $ do
	functionName x `shouldBe` y
}
\end{lstlisting}

\section{Rust}
The idea behind Rust programming language was to challenge the notion that high-level ergonomics and low-level control come at the cost of each other\cite{Rust_Book}.
Most programming languages today operate in a band where either safety or control is valued highest and the other diminished. An example of this is C, which has high level control but lacks safety.
Rust provides the low-level power of C along with the safety features programmers have gotten used to in high-level languages like Python.
As such, the main overall goal of Rust is to provide as much safety as possible in a low-level programming language without sacrificing performance. \cite{Rust_in_Action}

Our reason for using Rust is twofold:
\begin{enumerate}
    \item Rust is compiled to native machine code, which ensures that no additional overhead is introduced by a language runtime.
    \item Rust features safe implementations of threading and concurrency, which is useful for web applications where scalability is a priority.
\end{enumerate}

Rust also features a rich ecosystem of packages known as \textit{crates} managed by its package manager Cargo\cite{Cargo}. Several crates were used for the development of the platform. These will be introduced in chapter \ref{chap:TestRunner}.

\section{Docker}
Docker can be used to create uniform code execution environments with the use of images\cite{Docker_Container}.
An image is similar to an executable package that encapsulates everything required in order to run applications. 
When executed, the image is turned into a container.
Containers are isolated processes of bundles of code and required dependencies. 
This allows developers to move around prepackaged applications, ensuring that the developed software runs the same regardless of what operating system it runs on\cite{Docker_Container}.
We use Docker to set up local development environments for different platform components. This results in an easier development process and a simplified delivery process to production.


\section{tRPC}
tRPC is a library that enables developers to build type safe APIs without having to deal with schemas or code generation.
It is structured in a way that allows for types to be shared between the client and server by only importing the types instead of the actual server code.
This, in turn, allows developers to not expose the actual server code on the \frontend{}.
Furthermore, tRPC is created in a way that takes full advantage of the power of a full-stack TypeScript project\cite{tRPC}.
In tRPC, a query is like a read operation, while a mutation is similar to create, update, or delete operations.

\section{Prisma}
Prisma is a 2nd generation object-relational mapper (ORM) developed for use in Node.js and \typescript{} backends.
Its goal is to increase developer productivity by enabling development using a type-safe API for database queries that return \javascript{} objects.
This is achieved by providing type-safe database queries, allowing validation at compile time as well as introducing constraints to prevent common pitfalls\cite{Prisma_Why}.
Prisma enables productivity improvements by allowing developers to define application models through a data modeling language, granting an easier way of configuring the application data sources and models\cite{Prisma_Doc}.

\section{TypeScript}
As the server-side use of \javascript{} keeps growing in popularity, its inability to provide strong type checking and compile time errors often hinders it from being the preferred language.
\typescript{} was designed to address these problems without requiring JavaScript developers to learn a new language.
It is a syntactic superset of \javascript{} with additional features.
This means that all \javascript{} projects are syntactically valid \typescript{}. This, in turn, allows a development team to gradually adopt \typescript{} into their project and use \typescript{} and \javascript{} interchangeably\cite{TypeScript}.
\typescript{} accomplishes this while still keeping the advantages of an interpreted language by compiling into \javascript{}.

\section{Next.js}
Next.js (Next) is an open-source React framework created by Vercel that enables React web applications to use server-side rendering as well as generate static websites. The Next framework was created in order to counter the potential security issues of React, which relies on client-side rendering. Next provides a solution to this by enabling websites to be fully or partially server-side rendered\cite {Nextjs_Docks}.

Next also tries to fix another issue of React, namely that creating a website still requires spending a lot of time configuring tools as well as rebuilding solutions.
Next tries to combat this by providing building blocks for creating fast web application.
However, for each part of the application, the developer must still decide whether to build a solution themselves or use other tools such as libraries and frameworks \cite{Nextjs_Docks}.
We decided to use use Next because it is highly configurable, and provides useful abstractions and tools.

\section{PostgreSQL}
PostgreSQL (Postgres) is an open-source, object-relational database management system originally developed at the University of California, Berkley. Originally only designed for UNIX-like platforms, Postgres today runs on all major operating systems like Windows and MacOS\cite{Postgres_Docs}.
As a rule, the Postgres development team tries to conform to the SQL standards whenever these standards do not contradict Postgres features and as long as the standards do not lead to a deterioration of the architecture or performance\cite{Postgres_Docs}.

Today, Postgres features transactions which support Atomicity, Consistency, Isolation, and Durability (ACID) properties, as well as automatic update of views, foreign keys, and procedures.
Furthermore, modern Postgres supports a wide variety of deployment options from single machine usage to data warehouses and web services\cite{Postgres_Docs}.

\section{Usability Testing}
To evaluate a user interface, it can be useful to test its usability. ISO 9421 defines usability as
\begin{quote}
	"The effectiveness, efficiency and satisfaction with which specified users achieve specified goals in particular environments."
\end{quote}

Where effectiveness regards how well the users accomplished their goal, efficiency regards the resources expended in relation to the completeness of the goals, and lastly, satisfaction regards the comfort of the system to the users.
To test usability, one may perform a usability test. This is a study of the interaction that users have with a product. The test is performed by first letting the users operate the system, and then conducting a structured interview. This is done to identify usability problems in a system, and results in a list of usability problems and knowledge about how easily a user is able to interact with the system.
Before the test, the interviewers have to ensure that a test plan is ready.
They also need to prepare tasks and questions for the test subjects, and ensure that the necessary equipment works.
During the test, representative users should interact with the design while solving tasks and thinking out loud. The interviewer collects data during this process. It is important that the interviewer interferes as little as possible by only providing help if the user is stuck.
\cite{deb7} We use this method along with the System Usability Scale to perform a usability test on our system.

\subsection{System Usability Scale} \label{sec:SUSScore}
The System Usability Scale (SUS) is a standardized set of usability questions that can be distributed to users of the the system.
Their answers can then be used to compare a user interface to user interfaces from other systems.
SUS provides an overall score of the system from the user's perspective.
Other questions can be added about specific issues that testers believe should be addressed, but it will not be accounted for in the SUS score.\cite{adobeSUS}

The 10 questions in the System Usability Scale used to determine the score can be seen below.
\begin{enumerate}
	\item I think that I would like to use this system frequently.
	\item I found the system unnecessarily complex.
	\item I thought the system was easy to use.
	\item I think that I would need the support of a technical person to be able to use this system.
	\item I found the various functions in this system were well integrated.
	\item I thought there was too much inconsistency in this system.
	\item I imagine that most people would learn to use this system very quickly.
	\item I found the system very cumbersome to use.
	\item I felt very confident using the system.
	\item I needed to learn a lot of things before I could get going with this system.
\end{enumerate}
The answers are based on a 5 point scale from strongly disagree to strongly agree.
Each answer grants 1-5 points.
The questions alternate between positive and negative questions. The odd numbered questions are positive, and the even numbered questions are negative.\cite{adobeSUS}
To calculate the SUS score, there are three steps:
\begin{enumerate}
	\item For odd items: summarize the total score, then subtract 5.
	\item For even items: summarize the total score, then subtract the total score from 25
	\item Add up the total scores and multiply that total by 2.5.
\end{enumerate}
If the system achieves a SUS score above 68, it means that the UI is above average. Otherwise, if it is below 68, it is below average\cite{adobeSUS}.
We use SUS in order to get an overall rating of our system.

By performing a usability test utilizing structured interview and SUS, we get a concrete metric for scoring the system as well concrete feedback from the users.

\section{BenchmarkDotnet}
Availability is a quality measurement used to describe the probability of a system being available to a user when needed. Similarly, reliability is a measurement for determining the likelihood of correct system operation within a given time frame. \cite{reliabilityAvailability}
Stress testing is an approach that can help identify unintended behavior of a system that is only reached when the system performs under heavy workloads.
It can also be used to approximate when the system stops functioning.
Usually, one performs stress testing by exposing the system under test to a number of computations that are beyond its expected capabilities until it either stops or produces results too slowly to be considered usable\cite{Sommerville10}.
The expected capabilities are often described in an operational profile\cite{OperationalProfiles}.
Such a profile can, in combination with stress testing, be used to ensure that a system is both reliable and available, even when pushed beyond its expected workload.

BenchmarkDotnet\cite{Benchmarkdotnet} is a benchmarking framework allowing time measurements of operations performed in .NET runtimes.
It allows parameterization of measured operations and provides ways to introduce warm-up operations and adjustments.
We use this framework to create a stress test environment that simulates stressful client behavior and measures the response times for the system under test.