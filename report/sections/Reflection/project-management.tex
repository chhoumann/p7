In the following section, we will describe how the project was managed, which techniques were used, as well as which issues we encountered.
Throughout the section, we reflect on the decisions made in this context.

\section{Task Management}
One of the primary objectives in any project is to manage the tasks created throughout the project. The goal is to maintain an overview of what has been done, what needs to be done, and how the tasks are distributed between developers. Additionally, project managers also often want to be able to estimate how long tasks may take to complete and how difficult they are. To accomplish this, projects may utilize several project management tools and techniques. In this section, we will focus on the tools that we utilized. Afterwards in section \ref{sec:agile-dev}, we will focus on the techniques that were utilized to manage the project.

\subsection{GitHub Projects}
GitHub Projects seemed promising, as it supposedly integrates with existing developer workflows. You track issues and as you work on them, they flow from the backlog to \textit{in progress}, then to \textit{in review}, and then finally to \textit{completed}. When you submit a pull request, the related issue is moved to the \textit{in review} section, so other members are aware that it is pending. And when that pull request is merged, it is move to \textit{completed} automatically.
Intuitively, it makes sense to track issues like this, as it is closely aligned with the modern Git workflow on GitHub. To start contributing to a codebase, you create a branch. Then you reference issues when you make a pull request, which will then become linked to your changes, making issues closely tied to actual code changes.
However, we found that some group members were not accustomed to this way of working and.
This led to the idea of automation failing, as we often had to manually move issues around when project members forgot to relate issues to pull requests.
Managing a project generally includes managing non-technical tasks as well, which is hard to track with GitHub Projects, as it is designed specifically for software development.
What ultimately led us to explore other options were the frequent bugs related to automated workflows not being invoked, resulting in confusion.

\subsection{Notion}
Notion is a platform that allows users to organize resources and manage projects in the same space. The platform allows customizing the layout of a workspace in a way that best suits the team. One particular feature of Notion we used in this project was the Kanban board feature. Inside the Kanban board, we defined four categories, similar to what we had in GitHub Projects, in which we could place work items:

\begin{itemize}
    \item Not started
    \item In progress
    \item Review required
    \item Done
\end{itemize}

While Notion provides fewer features in terms of integration with GitHub, the tool was familiar to us and provided the functionality that we needed to manage the project.
Once we switched to Notion, planning and updating the tasks became a more active part of our workflow. This led to increased productivity, as we were now able to properly maintain an overview of what each member of the group was doing, and how much progress they had made on each task.

\section{Agile Development Approach} \label{sec:agile-dev}
Irrespective of which tools we used, the goal from the beginning of the project was to use a Scrum-like approach to project management.
This decision was based on previous experience working with a more rigid Scrum methodology in a school project setting, which we experienced leading to decreased productivity.
Generally, Scrum is a framework that helps teams and organizations generate value through flexible solutions to complex problems. Scrum is an iterative and incremental approach to project work where the project is divided into sprints. A sprint is a time frame, usually one to four weeks in length, during which the the team tries to complete the work that has been selected from a product backlog\cite{sutherlandScrumArtDoing2014}.

We only adopted the specific things from Scrum that we felt were necessary. For our project, we did not have a Scrum Master or Product Owner. Instead, we collectively created tasks based on features that we deemed necessary to implement.
In traditional Scrum, you would have Product Owners that talk to customers about which features are important to them. Since all group members are both stakeholders and developers, we found that acting as a council is more effective than delegating the role to a single member.

Additionally, instead of traditional sprints, we first designed the specifications for a minimum viable product consisting of only the core features that we deemed necessary for this type of project.
We then prioritized these features, focusing primarily on those that fulfill the use cases we designed for the platform, grouping them according to the MoSCoW analysis from chapter \ref{chap:Specification}.
During previous semesters, we discovered that sprints do not work well in university semester projects, as work hours vary and you usually work for less than half of the work week.
Based on previous experience, we found that smaller tasks and lowering the analytical overhead that Scrum brings fits these projects well.

During development, we adopted a pair programming approach. This means only one person writes code while the other person aids by finding information and spotting errors in the code. This technique was adopted as we found it productive in previous projects.
Besides pair programming, we also had a strict rule regarding code review. Anyone working on a specific feature would not be able to merge their code into production. This would only be possible after other group members reviewed the code.
If the code reviewers did not understand or agree with the implementation, the authors of the code were obliged to explain it, and sometimes refactor it to increase its readability and overall quality.
This meant that all features that were implemented were checked by at least two group members, ensuring fewer bugs and a collective understanding.


%introduction
%github projects failed - pivoted to kanban board
%agile development
%ci/cd
%code reviews
%pair programming
%scrum