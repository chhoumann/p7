In the following section, we will describe how the project was managed, which techniques were used, as well as which issues we encountered.
Throughout the section, we reflect on the decisions made in this context.

\section{Task Management}
One of the primary objectives in any project is to manage the tasks created throughout the project. The goal is to maintain an overview of what has been done, what needs to be done, and how the tasks are distributed between developers. Additionally, project managers also often want to be able to estimate how long tasks may take to complete and how difficult they are. To accomplish this, projects may utilize several project management tools and techniques. In this section, we will focus on the tools that we utilized. Afterwards in section \ref{sec:agile-dev}, we will focus on the techniques that were utilized to manage the project.

\subsection{GitHub Projects}
GitHub Projects seemed promising, as it supposedly integrates with existing developer workflows. You track issues and as you work on them, they flow from the backlog to \textit{in progress}, then to \textit{in review}, and then finally to \textit{completed}. When you submit a pull request, the related issue is moved to the \textit{in review} section, so other members are aware that it is pending. And when that pull request is merged, it is move to \textit{completed} automatically.
Intuitively, it makes sense to track issues like this, as it is closely aligned with the modern Git workflow on GitHub. To start contributing to a codebase, you create a branch. Then you reference issues when you make a pull request, which will then become linked to your changes, making issues closely tied to actual code changes.
However, we found that some group members were not accustomed to this way of working and.
This led to the idea of automation failing, as we often had to manually move issues around when project members forgot to relate issues to pull requests.
Managing a project generally includes managing non-technical tasks as well, which is hard to track with GitHub Projects, as it is designed specifically for software development.
What ultimately led us to explore other options were the frequent bugs related to automated workflows not being invoked, resulting in confusion.

\subsection{Notion}
Notion is a platform that allows users to organize resources and manage projects in the same space. The platform allows you to customize the layout of your work space in a way that best suits the team. One particular feature of Notion that we used in this project was the Kanban board. In the Kanban board we defined four categories, similar to what we had in Github Projects, in which we could place work items:

\begin{itemize}
    \item Not started
    \item In progress
    \item Review required
    \item Done
\end{itemize}

While Notion provides fewer features in terms of integration with Github, the tool was familiar to us and provided the functionality that we needed to manage the project.
Once we switched to Notion, planning and updating the tasks became a more active part of our daily work. This led to better productivity as we were now able to better maintain an overview of what each member of the group was doing and and how far they were with each task.

\section{Agile Development Approach} \label{sec:agile-dev}
Irrespective of which tools we used, the goal from the beginning of the project was to use a Scrum-like approach to project management.
The decision to this approach was based on previous experience working with a more rigid Scrum methodology in a school project setting which we had found to be less productive.
Generally, Scrum is a framework that helps teams and organizations generate value through flexible solutions to complex problems. Scrum is an iterative and incremental approach to project work where the project is broken up into sprints. A sprint being a time frame, usually 1-4 weeks in length, in which the the teams tries to complete the work that has been selected from a product backlog\cite{sutherlandScrumArtDoing2014}.

We only adopted the specific things from Scrum that we felt were necessary. For our project we did not have a Scrum master or product owner. Instead, we collectively created tasks based on features that we felt were necessary to implement.
In traditional Scrum, you would have product owners that talk to customers about which features are important to them. Since all group members are both stakeholders and developers, we found that acting as a council is more effective than delegating the role to a single member.

Additionally, instead of traditional sprints, we designed the specifications for a minimum viable product, consisting of only the core features that we deemed necessary for the success of this type of project.
This is akin to filling the project backlog with all features that could be in the project. Then we went on to prioritize the features again, focusing on features that fulfilled the use cases we imagined for the platform, grouping them as seen in the MoSCoW analysis in chapter \ref{chap:Specification}.
We found that sprints do not fit the nature of semester projects, as you have varying time to work, and it is usually less than half of the work week. We have found, based on previous experience, that smaller tasks and less analytical overhead, which Scrum brings, fits these projects well.

When developing the features we adopted a pair programming approach. This was done having only one member doing the actual programming while the other would be ready to assist by finding information and spotting errors in the code. This technique was adopted as we knew from previous projects that this type of partnership was productive. Besides pair programming, we also had a strict rule regarding code review. Anyone working on a specific feature would not be able to merge their code into production. This would only be allowed, and done, by other members after a review of the code. If the code reviewers did not understand the implementation, the designers of the code were obliged to showcase and explain the code in group meetings. This meant that all features, that were implemented, had been checked by at least two sources and therefore ensuring fewer bugs and a collective understanding.


%introduction
%github projects failed - pivoted to kanban board
%agile development
%ci/cd
%code reviews
%pair programming
%scrum