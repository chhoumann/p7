\chapter{Test Runner} \label{chap:TestRunner}
One of the primary goals of this application to give the professor a way to specificy what constitutes a correct problem solution.
As previously mentioned in chapter \ref{section:xxx} \todo{Fix ref. Probably write this earlier. Talk reader through decision of specifying criteria->automated checking for fast feedback->test runner}, a common approach to this is the use of test cases.

\section{Cilent-server interaction}
When a teacher creates a new exercise, a modal prompts them to enter details about the exercise.
These details include the name of the exercise, instructions for the student, an optional code template to help the student get started, as well as test code.
This data is sent to the database where it is stored.

When a student opens an exercise, the data is then fetched from the database.
This is done by the client sending a request to the Next.js backend, which queries the database and returns both exercise and test data.

In the interest of reducing the number of database queries, the result of this request is cached on the client. 
The client will eagerly request new data to stay up to date with instructions or test code updates.
We deemed that this short cache storage time is useful for when teachers update test code during an exercise session.
This way, all students have the latest test code shortly after the update while still minimizing unnecessary queries.

When a user submits their exercise solution attempt, a mutation\footnote{In the framework we use, a mutation is simply an umbrella term for create, update, and delete operations.} is sent to the Next.js backend.
In this request, the necessary code and test code is included. 
One could argue that fetching the test code on the backend when processing this mutation would be more approriate.
However, we want to eventually display the test code to the user so they may gain a better understanding of the solution requirements, although this will not be done in this iteration of the project.

To handle this mutation, the Next.js server requests the test runner to process the given solution and test code.
This process is described in section \label{sec:test_runner_process} below.
 
The response of this request to the test runner is validated and stored as a submission in the database. 
This allows users and teachers to access previous submissions, which includes code and a value indicating whether the submission satisfied the exercise tests.

Lastly, the result is sent to the client and displayed on the page.
\todo{Lots of screenshots! Show problem create modal, success code output and unsuccessful code output.}


\section{Test runner microservice process} \label{sec:test_runner_process}
When the test runner receives the request from Next.js, its singular goal is to run the tests against the code and send the result of this back as fast as possible.
% LÃ¦gger op til at vi kan snakke om hvordan vi har gjort det Blazingly Fast (TM)






% What happens on the front end?
    % Created by the teacher
    % Stored in the database
    % Fetched from db when student loads an exercise
    % Sent along with the request to the backend
% What happens on the backend?
    % Endpoint receieves request
    % We use hspec because it was human readable DSL (easier to read than i.e. HUnit).
    % runhaskell process is started which executes the tests
    % Random directory generator + clean-up
    % Upon completion of tests, result is sent back to the frontend/student/user.